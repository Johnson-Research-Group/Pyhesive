#! /usr/bin/env python3
import sys, argparse, logging, meshio, pymetis
import numpy as np
from collections import defaultdict
from scipy import sparse

class OptionsDataBase:
    MeshFileIn = None
    MeshFormatIn = None
    verbosity = 1
    vlevel = 50
    stream = sys.stdout.name

    def __init__(self):
        pass

class Mesh:
    cDim = 0
    cells = None
    verts = None
    c2v = {}
    v2c = defaultdict(list)
    c2c = None
    v2v = None

    def __init__(self, meshIn):
        if not isinstance(meshIn, meshio.Mesh):
            raise TypeError("Opts must be of type" + type(OptionsDataBase))
        self.cells = meshIn.cells_dict['tetra']
        self.verts = meshIn.points
        self.cDim = 4

    def Setup(self):
        self.Symmetrize()
        self.GenerateAdjacency()

    def Symmetrize(self):
        ne = len(self.cells)
        element_ids = np.empty((ne, self.cDim), dtype=np.intp)
        element_ids[:] = np.arange(ne).reshape(-1, 1)

        V2E = sparse.coo_matrix(
            (np.ones((ne*self.cDim,), dtype=np.intp),
            (self.cells.ravel(),
            element_ids.ravel(),)))
        self.c2c = V2E.T @ V2E
        self.v2v = V2E @ V2E.T
        del V2E
        self.c2c.eliminate_zeros()
        self.v2v.eliminate_zeros()

        self.c2v = dict(enumerate(self.cells))
        for cell,vlist in self.c2v.items():
            for vertex in vlist:
                self.v2c[vertex].append(cell)
        self.v2c = {k:np.array(v) for k, v in self.v2c.items()}

    def GenerateAdjacency(self):
        #E2E = V2E.T @ V2E
        #V2V = V2E @ V2E.T
        pass


    def Partition(self):
        pass


class CGen:
    log = None
    OptCtx = None
    Mesh = None

    def __init__(self, Opts):
        if not isinstance(Opts, OptionsDataBase):
            raise TypeError("Opts must be of type" + type(OptionsDataBase))
        slog = logging.getLogger(__name__)
        slog.setLevel(Opts.vlevel)
        slog.propagate = False
        ch = logging.StreamHandler(Opts.stream)
        ch.setLevel(Opts.vlevel)
        ch.propagate = False
        formatter = logging.Formatter('%(message)s')
        ch.setFormatter(formatter)
        slog.addHandler(ch)
        self.log = slog
        self.OptCtx = Opts

    def SetMesh(self, msh):
        self.Mesh = Mesh(msh)

    def Setup(self):
        self.Mesh.Setup()

    def PartitionMesh(self):
        self.Mesh.Partition()

def CGenInitialize():
    args = OptionsDataBase()
    path = "<path>"
    string = "<string>"
    parser = argparse.ArgumentParser(description='Insert Cohesive Elements Into Mesh', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-i', '--input', required=False, metavar=path, help='Specify the input mesh file', dest='MeshFileIn')
    parser.add_argument('-f', '--format', required=False, metavar=string, help='Specify the input mesh file format', dest='MeshFormatIn')
    parser.add_argument('-l', '--log-file', nargs=1, default=sys.stdout.name, metavar=path, help='Log output to file instead of STDOUT', dest='stdout')
    parser.add_argument('-v', '--verbose', default=0, action='count', help='Increase verbosity of logging statements, default no logging', dest='verbosity')
    parser.parse_args(namespace=args)
    for verb in range(args.verbosity):
        if args.vlevel >= 20: args.vlevel -= 10
    cgen = CGen(args)
    del args
    return cgen

def main():
    CGen = CGenInitialize()
    meshIn = meshio.read(CGen.OptCtx.MeshFileIn, CGen.OptCtx.MeshFormatIn)
    CGen.SetMesh(meshIn)
    CGen.Setup()
    CGen.PartitionMesh()
    return

if __name__ == "__main__":
    main()
