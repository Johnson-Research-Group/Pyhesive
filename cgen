#! /usr/bin/env python3
import sys, argparse, logging, meshio, pymetis, atexit, gc
import numpy as np
from collections import defaultdict
from scipy import sparse

infoDict = {
    'tetra' : [3, 4],
    'triangle' : [2, 3]
    }

class OptionsDataBase:
    __MeshFileIn = None
    __MeshFormatIn = None
    __verbosity = 1
    __vlevel = 50
    __stream = sys.stdout.name
    __registered_exit = False

    def __init__(self):
        self.__vlevel = 50
        if not self.__registered_exit:
            atexit.register(self.Finalize)
            self.__registered_exit = True

    def Finalize(self):
        self.__stream.flush()
        atexit.unregister(self.Finalize)
        self.__registered_exit = False

class CGen:
    __log = None
    __OptCtx = None
    __Mesh = None
    __registered_exit = False

    def __init__(self, Opts):
        if not self.__registered_exit:
            atexit.register(self.Finalize)
            self.__registered_exit = True
        if not isinstance(Opts, OptionsDataBase):
            raise TypeError("Opts must be of type" + type(OptionsDataBase))
        slog = logging.getLogger(self.__class__.__name__)
        slog.setLevel(Opts._OptionsDataBase__vlevel)
        slog.propagate = False
        ch = logging.StreamHandler(Opts._OptionsDataBase__stream)
        ch.setLevel(Opts._OptionsDataBase__vlevel)
        ch.propagate = False
        formatter = logging.Formatter('%(message)s')
        ch.setFormatter(formatter)
        slog.addHandler(ch)
        self.__log = slog
        self.__OptCtx = Opts

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, tb):
        if exc_type is not None:
            import traceback
            traceback.print_exception(exc_type, exc_value, tb)
        self.Finalize()
        return True

    def Finalize(self):
        self.__Mesh.Finalize()
        self.__OptCtx.Finalize()
        self.__Mesh = None
        self.__OptCtx = None
        handlers = self.__log.handlers[:]
        for handler in handlers:
            handler.flush()
            handler.close()
            self.__log.removeHandler(handler)
        self.__log = None
        atexit.unregister(self.Finalize)
        self.__registered_exit = False

    def Setup(self):
        msh = meshio.read(self._CGen__OptCtx._OptionsDataBase__MeshFileIn,
                          self._CGen__OptCtx._OptionsDataBase__MeshFormatIn)
        self.__Mesh = Mesh(self._CGen__OptCtx, msh)
        self.__Mesh.Setup()

    def PartitionMesh(self):
        self.__Mesh.Partition()

class Mesh:
    __log = None
    __cDim = 0
    __coords = None
    __cells = None
    __bdCells = []
    __faceDim = 0
    __nFaces = 0
    __nc = 0
    __c2v = {}
    __v2c = defaultdict(list)
    __cAdj = []
    __registered_exit = False

    def __init__(self, Opts, meshIn):
        if not self.__registered_exit:
            atexit.register(self.Finalize)
            self.__registered_exit = True
        slog = logging.getLogger(self.__class__.__name__)
        slog.setLevel(Opts._OptionsDataBase__vlevel)
        slog.propagate = False
        ch = logging.StreamHandler(Opts._OptionsDataBase__stream)
        ch.setLevel(Opts._OptionsDataBase__vlevel)
        ch.propagate = False
        formatter = logging.Formatter('%(message)s')
        ch.setFormatter(formatter)
        slog.addHandler(ch)
        self.__log = slog
        if not isinstance(meshIn, meshio.Mesh):
            raise TypeError("Opts must be of type" + type(OptionsDataBase))
        self.__ctype = meshIn.cells[-1].type
        self.__cells = meshIn.cells_dict[self.__ctype]
        self.__coords = meshIn.points
        self.__cDim = len(self.__cells[0])
        self.__faceDim = infoDict[self.__ctype][0]
        self.__nFaces = infoDict[self.__ctype][1]
        self.__nc = len(self.__cells)

    def Finalize(self):
        handlers = self.__log.handlers[:]
        for handler in handlers:
            handler.flush()
            handler.close()
            self.__log.removeHandler(handler)
        self.__log = None
        atexit.unregister(self.Finalize)
        self.__registered_exit = False

    def l2s(self, mylist):
        return ', '.join(map(str, myList))

    def Setup(self):
        self.Symmetrize()
        self.GenerateAdjacency()
        gc.collect()

    def Symmetrize(self):
        self.__c2v = dict(enumerate(self.__cells))
        for cell,vlist in self.__c2v.items():
            for vertex in vlist:
                self.__v2c[vertex].append(cell)
        self.__v2c = {k:np.array(v) for k, v in self.__v2c.items()}

    def BuildAdjacencyMatrix(self, format=None):
        def matsize(a):
            sum = 0
            if isinstance(a, sparse.csr_matrix) or isinstance(a, sparse.csc_matrix):
                sum = a.data.nbytes + a.indptr.nbytes + a.indices.nbytes
            elif isinstance(a, sparse.lil_matrix):
                sum = a.data.nbytes + a.rows.nbytes
            elif isinstance(a, sparse.coo_matrix):
                sum = a.col.nbytes + a.row.nbytes + a.data.nbytes
            return sum
        ne = self.__nc
        element_ids = np.empty((ne, self.__cDim), dtype=np.intp)
        element_ids[:] = np.arange(ne).reshape(-1, 1)

        v2e = sparse.coo_matrix(
            (np.ones((ne*len(element_ids[0]),), dtype=np.intp),
            (self.__cells.ravel(),
            element_ids.ravel(),)))
        v2e = v2e.tocsr(copy=False)
        c2c = v2e.T @ v2e
        v2v = v2e @ v2e.T
        self.__log.info("c2c mat size %d bytes" % matsize(c2c))
        c2c = c2c.asformat(format, copy=False)
        self.__log.info("c2c mat size after compression %d bytes" % matsize(c2c))
        self.__log.info("v2v mat size %d bytes" % matsize(v2v))
        v2v = v2v.asformat(format, copy=False)
        self.__log.info("v2v mat size after, compression %d bytes" % matsize(v2v))
        return c2c, v2v

    def GenerateAdjacency(self):
        def symmetric(a, atol=1e-10):
            return (abs(a-a.T)>atol).nnz == 0

        c2c, _ = self.BuildAdjacencyMatrix(format='lil')
        faceDim = self.__faceDim
        nfaces = self.__nFaces
        self.__cAdj = [[] for _ in range(len(self.__cells))]
        for rowindex, row in enumerate(c2c.data):
            sharedfaces = [i for i,k in enumerate(row) if k == faceDim]
            rowV = c2c.rows[rowindex]
            self.__cAdj[rowindex] = [rowV[j] for j in sharedfaces]
            #self.log.debug("cell %d adjacent to %s" % (rowindex, self.l2s(self.__cAdj[rowindex])))
            if (len(sharedfaces) != nfaces):
                self.__bdCells.append(rowindex)
                self.__log.debug("cell %d marked on boundary" % (rowindex))

    def Partition(self):
        npart = int(np.ceil(self.__nc/10))
        ncuts, mem = pymetis.part_graph(npart, adjacency=self.__cAdj)
        return

def OptionsInitialize():
    gc.set_debug(gc.DEBUG_UNCOLLECTABLE | gc.DEBUG_SAVEALL)
    args = OptionsDataBase()
    path = "<path>"
    string = "<string>"
    parser = argparse.ArgumentParser(description='Insert Cohesive Elements Into Mesh', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-i', '--input', required=True, metavar=path, help='Specify the input mesh file', dest='_OptionsDataBase__MeshFileIn')
    parser.add_argument('-f', '--format', required=False, metavar=string, help='Specify the input mesh file format', dest='_OptionsDataBase__MeshFormatIn')
    parser.add_argument('-l', '--log-file', nargs=1, default=sys.stdout.name, metavar=path, help='Log output to file instead of STDOUT', dest='_OptionsDataBase__stream')
    parser.add_argument('-v', '--verbose', default=0, action='count', help='Increase verbosity of logging statements, default no logging', dest='_OptionsDataBase__verbosity')
    parser.parse_args(namespace=args)
    if args._OptionsDataBase__stream is not sys.stdout.name:
        args._OptionsDataBase__stream = open(args._OptionsDataBase__stream[0], 'w')
    else:
        args._OptionsDataBase__stream = sys.stdout
    for verb in range(args._OptionsDataBase__verbosity):
        if args._OptionsDataBase__vlevel >= 20:
            args._OptionsDataBase__vlevel -= 10
    return args

def main():
    opts = OptionsInitialize()
    with CGen(opts) as cgen:
        cgen.Setup()
        cgen.PartitionMesh()

if __name__ == "__main__":
    main()
